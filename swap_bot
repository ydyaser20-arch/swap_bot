import asyncio
import json
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.filters import Command

TOKEN = "8483277417:AAGbkbkI_u_rBku5cGXyusUR7zPfRjilqGY"

bot = Bot(token=TOKEN)
dp = Dispatcher()

# Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„ÙØ¦Ø§Øª
SUBJECTS = [
    "Ù…Ø®Ø¨Ø± Ø§Ù„Ø¯Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©",
    "Ù…Ø®Ø¨Ø± Ù†Ø¸Ù… Ø§Ù„Ø­Ø§Ø³ÙˆØ¨ (Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù…ØªØ·ÙˆØ±Ø©)",
    "Ù…Ø®Ø¨Ø± Ù†Ø¸Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª (ØªØ­Ù„ÙŠÙ„ ÙˆØªØµÙ…ÙŠÙ…)",
    "Ù…Ø®Ø¨Ø± Ù†Ø¸Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª (Ù…ØªØ±Ø¬Ù…Ø§Øª)"
]
GROUPS = ["1", "2", "3", "4", "5", "6"]

DATA_FILE = "requests.json"


# ========== ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© ==========

def load_data():
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

def save_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def find_match(new_request):
    data = load_data()
    for req in data:
        if (
            req["user_id"] != new_request["user_id"] and
            req["subject"] == new_request["subject"] and
            req["current_group"] == new_request["target_group"] and
            req["target_group"] == new_request["current_group"]
        ):
            return req
    return None


# ========== Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ==========

@dp.message(Command("start"))
async def start_cmd(msg: types.Message):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ğŸ“ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ ØªØ¨Ø§Ø¯Ù„", callback_data="add_request")],
        [InlineKeyboardButton(text="ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø·Ù„Ø¨", callback_data="search_request")],
        [InlineKeyboardButton(text="ğŸ“‹ Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©", callback_data="show_all")],
        [InlineKeyboardButton(text="âŒ Ø­Ø°Ù Ø·Ù„Ø¨ÙŠ", callback_data="delete_request")],
    ])
    await msg.answer(
        "Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª ØªØ¨Ø§Ø¯Ù„ Ø§Ù„ÙØ¦Ø§Øª ğŸ‘‹\nØ§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª:",
        reply_markup=keyboard
    )


# ========== ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ ==========

@dp.callback_query(lambda c: c.data == "add_request")
async def add_request(callback: types.CallbackQuery):
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=s, callback_data=f"subject_{i}")]
            for i, s in enumerate(SUBJECTS)
        ]
    )
    await callback.message.answer("Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©:", reply_markup=keyboard)


@dp.callback_query(lambda c: c.data.startswith("subject_"))
async def choose_subject(callback: types.CallbackQuery):
    subject_index = int(callback.data.split("_")[1])
    subject = SUBJECTS[subject_index]

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=g, callback_data=f"cur_{subject_index}_{g}") for g in GROUPS]
        ]
    )
    await callback.message.answer(f"Ø§Ø®ØªØ± ÙØ¦ØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù…Ø§Ø¯Ø© {subject}:", reply_markup=keyboard)


@dp.callback_query(lambda c: c.data.startswith("cur_"))
async def choose_current_group(callback: types.CallbackQuery):
    _, subject_index, cur_group = callback.data.split("_")
    subject_index = int(subject_index)
    subject = SUBJECTS[subject_index]

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=g, callback_data=f"target_{subject_index}_{cur_group}_{g}")]
            for g in GROUPS if g != cur_group
        ]
    )
    await callback.message.answer(f"Ø§Ø®ØªØ± Ø§Ù„ÙØ¦Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„ÙŠÙ‡Ø§:", reply_markup=keyboard)


@dp.callback_query(lambda c: c.data.startswith("target_"))
async def choose_target_group(callback: types.CallbackQuery):
    _, subject_index, cur_group, target_group = callback.data.split("_")
    subject_index = int(subject_index)
    subject = SUBJECTS[subject_index]

    new_req = {
        "user_id": callback.from_user.id,
        "username": callback.from_user.username or "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
        "subject": subject,
        "current_group": cur_group,
        "target_group": target_group
    }

    data = load_data()
    # Ø­Ø°Ù Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯
    data = [r for r in data if r["user_id"] != callback.from_user.id]
    data.append(new_req)
    save_data(data)

    match = find_match(new_req)
    if match:
        await bot.send_message(
            match["user_id"],
            f"âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø·Ø§Ù„Ø¨ ÙŠØ±ÙŠØ¯ Ø§Ù„ØªØ¨Ø§Ø¯Ù„ Ù…Ø¹Ùƒ!\n"
            f"Ø§Ù„Ù…Ø§Ø¯Ø©: {subject}\n"
            f"Ù‡Ùˆ Ù…Ù† Ø§Ù„ÙØ¦Ø© {cur_group} ÙˆÙŠØ±ÙŠØ¯ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ {target_group}."
        )
        await callback.message.answer(
            f"âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªØ·Ø§Ø¨Ù‚!\nØ§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ø¢Ø®Ø±: @{match['username']}\n"
            f"Ù…Ù† {match['current_group']} Ø¥Ù„Ù‰ {match['target_group']} Ù„Ù…Ø§Ø¯Ø© {subject}"
        )
    else:
        await callback.message.answer("ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ âœ…\nØ³ÙŠØªÙ… Ø¥Ø¹Ù„Ø§Ù…Ùƒ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯ ØªØ·Ø§Ø¨Ù‚.")


# ========== Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø·Ù„Ø¨Ø§Øª ==========

@dp.callback_query(lambda c: c.data == "search_request")
async def search_request(callback: types.CallbackQuery):
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=g, callback_data=f"search_from_{g}") for g in GROUPS]
        ]
    )
    await callback.message.answer("Ø§Ø®ØªØ± ÙØ¦ØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ©:", reply_markup=keyboard)


@dp.callback_query(lambda c: c.data.startswith("search_from_"))
async def search_from(callback: types.CallbackQuery):
    cur_group = callback.data.split("_")[2]
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=g, callback_data=f"search_to_{cur_group}_{g}")]
            for g in GROUPS if g != cur_group
        ]
    )
    await callback.message.answer("Ø§Ø®ØªØ± Ø§Ù„ÙØ¦Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„ÙŠÙ‡Ø§:", reply_markup=keyboard)


@dp.callback_query(lambda c: c.data.startswith("search_to_"))
async def search_to(callback: types.CallbackQuery):
    _, _, cur_group, target_group = callback.data.split("_")
    data = load_data()
    found = [
        r for r in data if r["current_group"] == target_group and r["target_group"] == cur_group
    ]

    if not found:
        await callback.message.answer("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø·Ù„Ø§Ø¨ Ø­Ø§Ù„ÙŠÙ‹Ø§ ÙŠØ±ÙŠØ¯ÙˆÙ† Ø§Ù„ØªØ¨Ø§Ø¯Ù„ Ù…Ø¹Ùƒ.")
    else:
        msg = "Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…ØªØ§Ø­ÙˆÙ† Ù„Ù„ØªØ¨Ø§Ø¯Ù„:\n\n"
        for r in found:
            msg += f"ğŸ‘¤ @{r['username']} | Ù…Ø§Ø¯Ø©: {r['subject']} | Ù…Ù† {r['current_group']} Ø¥Ù„Ù‰ {r['target_group']}\n"
        await callback.message.answer(msg)


# ========== Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø© ==========

@dp.callback_query(lambda c: c.data == "show_all")
async def show_all(callback: types.CallbackQuery):
    data = load_data()
    if not data:
        await callback.message.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return

    msg = "ğŸ“‹ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©:\n\n"
    for r in data:
        msg += f"ğŸ‘¤ @{r['username']} | {r['subject']} | Ù…Ù† {r['current_group']} â†’ {r['target_group']}\n"
    await callback.message.answer(msg)


# ========== Ø­Ø°Ù Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø´Ø®ØµÙŠ ==========

@dp.callback_query(lambda c: c.data == "delete_request")
async def delete_request(callback: types.CallbackQuery):
    data = load_data()
    before = len(data)
    data = [r for r in data if r["user_id"] != callback.from_user.id]
    save_data(data)
    if len(data) < before:
        await callback.message.answer("âœ… ØªÙ… Ø­Ø°Ù Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­.")
    else:
        await callback.message.answer("âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ Ø·Ù„Ø¨ Ù…Ø³Ø¬Ù„.")


# ========== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ==========

async def main():
    print("ğŸ¤– Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
